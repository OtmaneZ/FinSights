// FinSight - Prisma Schema
// Database: PostgreSQL (Vercel Postgres)
// ORM: Prisma Client

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// USER MODEL - Authentification & Plans
// ============================================

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  password  String?  // bcrypt hash (10 rounds) - nullable for SSO users
  plan      Plan     @default(FREE)

  // OAuth SSO fields
  provider      String?  // "google", "microsoft", "credentials"
  providerId    String?  // OAuth provider user ID
  providerEmail String?  // Email from OAuth provider
  avatar        String?  // Profile picture URL

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  companies                Company[]
  dashboards               Dashboard[]
  apiKeys                  ApiKey[]
  webhooks                 Webhook[]
  companyMembers           CompanyMember[]
  invitationsSent          Invitation[]             @relation("InvitationsSent")
  accountingIntegrations   AccountingIntegration[]  @relation("AccountingIntegrations")

  // Settings
  notificationSettings Json? // Email alerts, thresholds, reports

  // Stripe Integration
  stripeCustomerId       String?   @unique
  stripeSubscriptionId   String?   @unique
  stripePriceId          String?
  stripeCurrentPeriodEnd DateTime?

  @@unique([provider, providerId]) // Un seul compte par provider/providerId
  @@index([email])
  @@index([provider])
  @@map("users")
}

// ============================================
// COMPANY MODEL - Multi-entreprises
// ============================================

model Company {
  id     String  @id @default(cuid())
  name   String
  sector String? // services, commerce, industrie, saas

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  dashboards             Dashboard[]
  members                CompanyMember[]
  invitations            Invitation[]
  accountingIntegrations AccountingIntegration[]
  createdAt              DateTime                @default(now())

  @@index([userId])
  @@map("companies")
}

// ============================================
// DASHBOARD MODEL - Fichiers uploadés
// ============================================

model Dashboard {
  id       String @id @default(cuid())
  fileName String
  fileUrl  String // Vercel Blob Storage URL

  // Données JSON
  rawData Json // Transactions parsées
  kpis    Json // KPIs calculés

  companyId String
  company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([companyId])
  @@index([userId])
  @@index([createdAt])
  @@map("dashboards")
}

// ============================================
// API KEY MODEL - API REST
// ============================================

model ApiKey {
  id      String  @id @default(cuid())
  keyHash String  @unique // SHA-256 hash de la clé (sécurité)
  name    String  // "Production API", "Development"
  prefix  String  // 8 premiers caractères (ex: "fs_a1b2c") pour identification

  userId   String
  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  lastUsed  DateTime? // Dernière utilisation
  expiresAt DateTime? // Date d'expiration (optionnelle)
  revoked   Boolean   @default(false) // Révocation manuelle

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([keyHash])
  @@index([revoked])
  @@map("api_keys")
}

// ============================================
// WEBHOOK MODEL - Real-time Events
// ============================================

model Webhook {
  id     String  @id @default(cuid())
  url    String  // Endpoint URL to POST events
  secret String  // Webhook signing secret
  active Boolean @default(true)

  // Event subscriptions (array of event types)
  events String[] // ["dashboard.created", "dashboard.updated", "kpi.threshold_reached"]

  userId        String
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  lastTriggered DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  logs WebhookLog[]

  @@index([userId])
  @@index([active])
  @@map("webhooks")
}

// ============================================
// WEBHOOK LOG MODEL - Delivery History
// ============================================

model WebhookLog {
  id String @id @default(cuid())

  webhookId String
  webhook   Webhook @relation(fields: [webhookId], references: [id], onDelete: Cascade)

  event       String // "dashboard.created"
  payload     Json   // Event data sent
  statusCode  Int?   // HTTP response code
  response    String? // Response body
  success     Boolean
  attempts    Int    @default(1) // Retry count
  errorReason String?

  createdAt DateTime @default(now())

  @@index([webhookId])
  @@index([createdAt])
  @@index([success])
  @@map("webhook_logs")
}

// ============================================
// PARSE LOG MODEL - Upload & AI Analytics
// ============================================

model ParseLog {
  id String @id @default(cuid())

  // User & File Info
  userId       String?
  fileName     String
  fileSize     Int     // Bytes
  mimeType     String? // MIME type détecté

  // Parse Method & Result
  parseMethod  ParseMethod // ai, classic, or error
  success      Boolean
  error        String?     // Error message if failed

  // Performance Metrics
  executionTime Int?       // Milliseconds
  tokensUsed    Int?       // OpenAI tokens (only for AI)
  recordsFound  Int?       // Number of transactions parsed

  // Metadata
  aiModel       String?    // e.g., "gpt-4-turbo-preview"
  fallbackUsed  Boolean    @default(false) // True if AI failed and classic parser was used

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([parseMethod])
  @@index([success])
  @@index([createdAt])
  @@map("parse_logs")
}

// ============================================
// ENUMS
// ============================================

enum ParseMethod {
  AI       // AI parser (Gemini Flash full parsing)
  CLASSIC  // Fallback CSV parser
  HYBRID   // Classic parser (exhaustive) + AI enrichment (large files)
  ERROR    // Failed before parsing
}

enum Plan {
  FREE        // Ancien: FREE → Nouveau display: "Starter"
  PRO         // Ancien: PRO → Nouveau display: "Business" (99€/mois)
  SCALE       // Ancien: SCALE → Nouveau display: "Growth" (199€/mois)
  ENTERPRISE  // Inchangé
}

enum Role {
  OWNER       // Créateur de l'entreprise (tous les droits)
  ADMIN       // Administrateur (gestion membres + dashboards)
  EDITOR      // Éditeur (upload, édition dashboards)
  VIEWER      // Lecteur seul (consultation dashboards)
}

enum InvitationStatus {
  PENDING     // En attente d'acceptation
  ACCEPTED    // Acceptée
  DECLINED    // Refusée
  EXPIRED     // Expirée (> 7 jours)
}

// ============================================
// COMPANY MEMBER MODEL - Collaboration
// ============================================

model CompanyMember {
  id String @id @default(cuid())

  companyId String
  company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  role Role @default(VIEWER)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([companyId, userId]) // Un user ne peut avoir qu'un rôle par entreprise
  @@index([companyId])
  @@index([userId])
  @@index([role])
  @@map("company_members")
}

// ============================================
// INVITATION MODEL - Collaboration
// ============================================

model Invitation {
  id String @id @default(cuid())

  email     String
  role      Role
  status    InvitationStatus @default(PENDING)

  companyId String
  company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  invitedBy String // User ID qui a envoyé l'invitation
  inviter   User   @relation("InvitationsSent", fields: [invitedBy], references: [id], onDelete: Cascade)

  // Token unique pour accepter l'invitation
  token     String   @unique
  expiresAt DateTime // Expiration à 7 jours

  acceptedAt DateTime?
  declinedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([companyId])
  @@index([email])
  @@index([status])
  @@index([token])
  @@map("invitations")
}

// ============================================
// ACCOUNTING INTEGRATION MODEL
// ============================================

model AccountingIntegration {
  id String @id @default(cuid())

  provider  String // "pennylane", "quickbooks", "xero"
  active    Boolean @default(true)

  // OAuth credentials (encrypted)
  accessToken  String? // OAuth access token
  refreshToken String? // OAuth refresh token
  expiresAt    DateTime?

  // Provider-specific data
  providerAccountId String? // ID du compte chez le provider
  metadata          Json?   // Metadata spécifique (webhooks, scopes, etc.)

  // Sync settings
  autoSync       Boolean  @default(false) // Sync automatique quotidien
  lastSyncAt     DateTime?
  syncFrequency  String   @default("daily") // "hourly", "daily", "weekly"

  companyId String
  company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation("AccountingIntegrations", fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([companyId, provider]) // Une seule intégration par provider par company
  @@index([companyId])
  @@index([userId])
  @@index([provider])
  @@map("accounting_integrations")
}

// ============================================
// LEAD MODEL - Email Nurturing Automation
// ============================================

model Lead {
  id        String   @id @default(cuid())
  email     String   @unique
  firstName String
  lastName  String?
  company   String?
  sector    String? // SaaS/Tech, Services B2B, Commerce/E-commerce, etc.

  // Lead tracking
  source       String   @default("template_download") // template_download, blog, calculator, consulting_page
  templateName String // "Prévisionnel Trésorerie 90j", "Budget Prévisionnel Startup", etc.

  // Email automation
  lastEmailSent       String   @default("welcome") // welcome, tutorial, case_study, alert_signals, daf_offer
  nextEmailScheduled  DateTime? // Date du prochain email automatique (null = séquence terminée)
  unsubscribed        Boolean  @default(false)

  // Engagement tracking
  emailOpens       Int      @default(0)
  emailClicks      Int      @default(0)
  lastEngagement   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([email])
  @@index([nextEmailScheduled])
  @@index([unsubscribed])
  @@index([source])
  @@map("leads")
}

// ============================================
// AI ASSISTANT - Conversations & Context
// ============================================

model AssistantConversation {
  id        String   @id @default(cuid())
  sessionId String   // localStorage ID ou user.id si logged in
  userId    String?  // Si user authentifié
  
  // Context snapshot au moment de la conversation
  currentPage       String?  // URL de la page
  calculatorHistory Json?    // Snapshot des calculs localStorage
  finSightScore     Int?     // Score au moment de la conversation
  
  // Conversation metadata
  startedAt   DateTime @default(now())
  lastMessage DateTime @default(now())
  messageCount Int     @default(0)
  
  // Engagement tracking
  clickedCTA  String?  // "consulting", "template", "calculator", etc.
  converted   Boolean  @default(false)
  
  messages AssistantMessage[]
  
  @@index([sessionId])
  @@index([userId])
  @@index([startedAt])
  @@map("assistant_conversations")
}

model AssistantMessage {
  id             String   @id @default(cuid())
  conversationId String
  
  role      String   // "user" | "assistant" | "system"
  content   String   @db.Text
  
  // AI metadata
  model         String?  // "gpt-4o-mini", "claude-3.5-sonnet"
  tokensUsed    Int?
  responseTime  Int?     // ms
  
  // Extracted CTAs from assistant response
  suggestedCTAs Json?    // [{ label: "Calculer BFR", href: "/calculateurs/bfr" }]
  
  createdAt DateTime @default(now())
  
  conversation AssistantConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  
  @@index([conversationId])
  @@index([createdAt])
  @@map("assistant_messages")
}
